# WARNING: IF THE CODE FAILS TO FIND VOTE COUNT
# REASON IS THAT LAMBDA IS FLOATING POINT VALUE
# ALL FAILURES MAY HAPPEN DUE TO THIS ^
# IF IT FAILS, EXECUTE OVER AND OVER AGAIN
# CODE IS WORKING FINE FOR INTEGER LAMBDA VALUES


import random
# This block generates multiplicative inverse


def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)


def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('Modular inverse does not exist')
    else:
        return x % m


def nToSum(N, S):
    ''' Creates a nested list of all possible lists of length N that sum to S'''
    if N <= 1:  # base case
        return [S]
    else:
        L = []
        for x in range(S+1):  # create a sub-list for each possible entry of 0 to S
            # create a sub-list for this value recursively
            L += [[x, nToSum(N-1, S-x)]]
        return L


def compress(n, L):  # designed to take in a list generated by nToSum
    '''takes the input from nToSum as list L, and then flattens it so that each list is a
       top level list.  Leading set n is the "prefix" list, and grows as you climb down the 
       sublists'''
    if type(L[0]) == int:  # base case:  you have exposed a pure integer
        return [n+L]  # take that integer, and prepend the leading set n
    else:
        Q = []
        for x in L:  # look at every sublist
            # for each sublist, create top level lists recursively
            Q += compress(n+[x[0]], x[1])
        return Q                          # note:  append x[0] to leading set n


def ShamirSecretSharing(n, t, s, q):
    # select t-1 random integers at random
    coefs = list()
    for _ in range(t-1):
        S_i = random.randint(0, q-1)
        coefs.append(S_i)
    # print('s', s)
    # print('coefs:', coefs)
    # Construct a secret polynomial by inserting secret to S[0]
    coefs = [s] + coefs
    # print('coefs1:', coefs)
    # Evaluate the polynomial by at n different values of x [1 .. n]
    s_a = list()
    for i in range(1, n+1):  # i is x
        y_i = 0
        for index, S_i in enumerate(coefs):
            y_i = (y_i + S_i * pow(i, index)) % q
        s_a.append(y_i)
    # print('s_a', s_a)
    return s_a


def PartialDecryption(X, a, Lambda, t, p):
    Omega = list()
    for i in range(t):
        s_a = Lambda[i]
        Omega_a = pow(X, s_a, p)
        Omega.append(Omega_a)

    return Omega


def calculate_lambda(a_i, a, q):
    l = 1
    for m in a:
        if m != a_i:
            denom = m - a_i + q
            denom = modinv(denom, q)
            l *= denom * m
    l = l % q
    return l


def FullDecryption(Y, a, Omega, G, t, p, q):
    # k and ell hardcoded
    a = [x+1 for x in a]  # spent at least 5 hours for this line
    X = 1
    for index, a_i in enumerate(a):  # get a and index of a
        # calculate lambda for each a
        l = calculate_lambda(a_i, a, q)
        # print('lambda: ', l) # debug
        # Omega_a ^ lambda
        X *= pow(Omega[index], q-int(l), p)
    result = (Y * X) % p

    comb = compress([], nToSum(4, 40))
    for c in comb:
        res = 1
        for i in range(len(G)):
            res *= pow(G[i], c[i], p)
        res = res % p
        # print('res1', res)
        # print('res2', result)
        if res == result:
            return c


def CheckQuorum(a, h_a_lambda, p, q):
    a = [x+1 for x in a]
    h = 1
    for index, a_i in enumerate(a):  # get a and index of a
        # calculate lambda for each a
        l = calculate_lambda(a_i, a, q)
        # Omega_a ^ lambda
        # print('l:', l)
        h = (h * pow(h_a_lambda[index], q+int(l), p)) % p
    # res = h % p
    return h


def ZK_commonexp(Lambda_i, h_a_lambda_i, Omega_i, p, q):

    # get g
    f_pk = open('pk.txt', 'r')  # file to public parameters
    _ = int(f_pk.readline())
    _ = int(f_pk.readline())
    g = int(f_pk.readline())
    f_pk.close()

    beta = Lambda_i
    r = random.randint(0, q-1)
    c = random.randint(0, q-1)
    z = r + beta * c
    a = pow(g, r, p)
    b = pow(h_a_lambda_i, r, p)
    u = h_a_lambda_i
    v = pow(h_a_lambda_i, beta, p)

    return pow(h_a_lambda_i, z, p) == ((pow(h_a_lambda_i, r, p)*pow(h_a_lambda_i, beta*c, p)) % p) and pow(g, z, p) == (a*pow(u, c, p)) % p
